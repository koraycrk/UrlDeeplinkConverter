package com.Url.Deeplink.Converter.Services;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import com.Url.Deeplink.Converter.Dto.ResponseDTO;
import com.Url.Deeplink.Converter.Enums.ErrorCodes;
import com.Url.Deeplink.Converter.Models.Transaction;
import com.Url.Deeplink.Converter.Repository.TransactionRepository;

@Component("urlstrategy")
public class UrlStrategy implements ConvertStrategy{

	@Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
	private TransactionRepository tranRepository;
	@Override
	public ResponseDTO Convert(String url) {
		// TODO Auto-generated method stub
		ResponseDTO result = new ResponseDTO();
		
		try {
			
			String deepLink = "ty://?Page=Transaction&ContentId=";
			URL convertedUrl = new URL(url);
			int contentId = 0;
			if(convertedUrl.getQuery() != null) {// has flowName param
				Pattern p = Pattern.compile("xyz.com/(.+)/(.+)\\?flowName");
				Matcher m = p.matcher(url);
				if (m.find() && m.groupCount() == 2 && m.group(2).split("-").length == 3){
					contentId = Integer.parseInt(m.group(2).split("-")[2]);
					var tran = tranRepository.findTransactionByContentId(contentId);
					if(tran == null || !convertedUrl.getQuery().split("=")[1].equals(tran.getFlowName())) {
						result.getHeader().setSuccess(false);
						result.getHeader().setCode(ErrorCodes.RecordNotFound.getValue());
						result.getHeader().setMessage(ErrorCodes.RecordNotFound.name());
						return result;
					}
					deepLink += contentId + "&flowId="+tran.getFlowId();
					result.setUrl(deepLink);
				}
				else {
					result.getHeader().setSuccess(false);
					result.getHeader().setCode(ErrorCodes.UrlNotMatched.getValue());
					result.getHeader().setMessage(ErrorCodes.UrlNotMatched.name());
					
				}
			}
			else {
				Pattern p = Pattern.compile("xyz.com/(.+)/(.+)");
				Matcher m = p.matcher(url);
				if (m.find() && m.groupCount() == 2 && m.group(2).split("-").length == 3){
					contentId = Integer.parseInt(m.group(2).split("-")[2]);
					var tran = tranRepository.findTransactionByContentId(contentId);
					if(tran == null) {
						result.getHeader().setSuccess(false);
						result.getHeader().setCode(ErrorCodes.RecordNotFound.getValue());
						result.getHeader().setMessage(ErrorCodes.RecordNotFound.name());
						return result;
					}
					deepLink += contentId;
					result.setUrl(deepLink);
				}
				else {
					result.getHeader().setSuccess(false);
					result.getHeader().setCode(ErrorCodes.UrlNotMatched.getValue());
					result.getHeader().setMessage(ErrorCodes.UrlNotMatched.name());
				}
			}
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			result.getHeader().setSuccess(false);
			result.getHeader().setCode(ErrorCodes.GeneralError.getValue());
			result.getHeader().setMessage(e.getMessage());
		}
		
		return result;
		
	}

}
